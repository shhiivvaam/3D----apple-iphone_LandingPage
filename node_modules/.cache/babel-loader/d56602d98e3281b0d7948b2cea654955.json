{"ast":null,"code":"import * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\nconst col = new THREE.Color();\nfunction Container(_ref) {\n  let {\n    canvasSize,\n    scene,\n    index,\n    children,\n    frames,\n    rect,\n    track\n  } = _ref;\n  const get = useThree(state => state.get);\n  const camera = useThree(state => state.camera);\n  const virtualScene = useThree(state => state.scene);\n  const setEvents = useThree(state => state.setEvents);\n  let frameCount = 0;\n  useFrame(state => {\n    if (frames === Infinity || frameCount <= frames) {\n      var _track$current;\n      rect.current = (_track$current = track.current) == null ? void 0 : _track$current.getBoundingClientRect();\n      frameCount++;\n    }\n    if (rect.current) {\n      const {\n        left,\n        right,\n        top,\n        bottom,\n        width,\n        height\n      } = rect.current;\n      const isOffscreen = bottom < 0 || top > canvasSize.height || right < 0 || left > canvasSize.width;\n      const positiveYUpBottom = canvasSize.height - bottom;\n      const aspect = width / height;\n      if (isOrthographicCamera(camera)) {\n        if (camera.left !== width / -2 || camera.right !== width / 2 || camera.top !== height / 2 || camera.bottom !== height / -2) {\n          Object.assign(camera, {\n            left: width / -2,\n            right: width / 2,\n            top: height / 2,\n            bottom: height / -2\n          });\n          camera.updateProjectionMatrix();\n        }\n      } else if (camera.aspect !== aspect) {\n        camera.aspect = aspect;\n        camera.updateProjectionMatrix();\n      }\n      state.gl.setViewport(left, positiveYUpBottom, width, height);\n      state.gl.setScissor(left, positiveYUpBottom, width, height);\n      state.gl.setScissorTest(true);\n      if (isOffscreen) {\n        state.gl.getClearColor(col);\n        state.gl.setClearColor(col, state.gl.getClearAlpha());\n        state.gl.clear(true, true);\n        return;\n      } // When children are present render the portalled scene, otherwise the default scene\n\n      state.gl.render(children ? virtualScene : scene, camera);\n    }\n  }, index);\n  React.useEffect(() => {\n    // Connect the event layer to the tracking element\n    const old = get().events.connected;\n    setEvents({\n      connected: track.current\n    });\n    return () => setEvents({\n      connected: old\n    });\n  }, []);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\nconst View = _ref2 => {\n  let {\n    track,\n    index = 1,\n    frames = Infinity,\n    children\n  } = _ref2;\n  const rect = React.useRef(null);\n  const {\n    size,\n    scene\n  } = useThree();\n  const [virtualScene] = React.useState(() => new THREE.Scene());\n  const compute = React.useCallback((event, state) => {\n    if (track.current && event.target === track.current) {\n      const {\n        width,\n        height,\n        left,\n        top\n      } = rect.current;\n      const x = event.clientX - left;\n      const y = event.clientY - top;\n      state.pointer.set(x / width * 2 - 1, -(y / height) * 2 + 1);\n      state.raycaster.setFromCamera(state.pointer, state.camera);\n    }\n  }, [rect]);\n  const [ready, toggle] = React.useReducer(() => true, false);\n  React.useEffect(() => {\n    var _track$current2;\n\n    // We need the tracking elements bounds beforehand in order to inject it into the portal\n    rect.current = (_track$current2 = track.current) == null ? void 0 : _track$current2.getBoundingClientRect(); // And now we can proceed\n\n    toggle();\n  }, []);\n  return ready && createPortal( /*#__PURE__*/React.createElement(Container, {\n    canvasSize: size,\n    frames: frames,\n    scene: scene,\n    track: track,\n    rect: rect,\n    index: index\n  }, children), virtualScene, {\n    events: {\n      compute,\n      priority: index\n    },\n    size: {\n      width: rect.current.width,\n      height: rect.current.height\n    }\n  });\n};\nexport { View };","map":{"version":3,"names":["React","THREE","useThree","createPortal","useFrame","isOrthographicCamera","def","col","Color","Container","_ref","canvasSize","scene","index","children","frames","rect","track","get","state","camera","virtualScene","setEvents","frameCount","Infinity","_track$current","current","getBoundingClientRect","left","right","top","bottom","width","height","isOffscreen","positiveYUpBottom","aspect","Object","assign","updateProjectionMatrix","gl","setViewport","setScissor","setScissorTest","getClearColor","setClearColor","getClearAlpha","clear","render","useEffect","old","events","connected","createElement","Fragment","View","_ref2","useRef","size","useState","Scene","compute","useCallback","event","target","x","clientX","y","clientY","pointer","set","raycaster","setFromCamera","ready","toggle","useReducer","_track$current2","priority"],"sources":["C:/Users/lifes/OneDrive/Desktop/Projects/3D Apple Landing Page/Apple-iphone-3d-landing-page-starter-Code/node_modules/@react-three/drei/web/View.js"],"sourcesContent":["import * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\n\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\n\nconst col = new THREE.Color();\n\nfunction Container({\n  canvasSize,\n  scene,\n  index,\n  children,\n  frames,\n  rect,\n  track\n}) {\n  const get = useThree(state => state.get);\n  const camera = useThree(state => state.camera);\n  const virtualScene = useThree(state => state.scene);\n  const setEvents = useThree(state => state.setEvents);\n  let frameCount = 0;\n  useFrame(state => {\n    if (frames === Infinity || frameCount <= frames) {\n      var _track$current;\n\n      rect.current = (_track$current = track.current) == null ? void 0 : _track$current.getBoundingClientRect();\n      frameCount++;\n    }\n\n    if (rect.current) {\n      const {\n        left,\n        right,\n        top,\n        bottom,\n        width,\n        height\n      } = rect.current;\n      const isOffscreen = bottom < 0 || top > canvasSize.height || right < 0 || left > canvasSize.width;\n      const positiveYUpBottom = canvasSize.height - bottom;\n      const aspect = width / height;\n\n      if (isOrthographicCamera(camera)) {\n        if (camera.left !== width / -2 || camera.right !== width / 2 || camera.top !== height / 2 || camera.bottom !== height / -2) {\n          Object.assign(camera, {\n            left: width / -2,\n            right: width / 2,\n            top: height / 2,\n            bottom: height / -2\n          });\n          camera.updateProjectionMatrix();\n        }\n      } else if (camera.aspect !== aspect) {\n        camera.aspect = aspect;\n        camera.updateProjectionMatrix();\n      }\n\n      state.gl.setViewport(left, positiveYUpBottom, width, height);\n      state.gl.setScissor(left, positiveYUpBottom, width, height);\n      state.gl.setScissorTest(true);\n\n      if (isOffscreen) {\n        state.gl.getClearColor(col);\n        state.gl.setClearColor(col, state.gl.getClearAlpha());\n        state.gl.clear(true, true);\n        return;\n      } // When children are present render the portalled scene, otherwise the default scene\n\n\n      state.gl.render(children ? virtualScene : scene, camera);\n    }\n  }, index);\n  React.useEffect(() => {\n    // Connect the event layer to the tracking element\n    const old = get().events.connected;\n    setEvents({\n      connected: track.current\n    });\n    return () => setEvents({\n      connected: old\n    });\n  }, []);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\n\nconst View = ({\n  track,\n  index = 1,\n  frames = Infinity,\n  children\n}) => {\n  const rect = React.useRef(null);\n  const {\n    size,\n    scene\n  } = useThree();\n  const [virtualScene] = React.useState(() => new THREE.Scene());\n  const compute = React.useCallback((event, state) => {\n    if (track.current && event.target === track.current) {\n      const {\n        width,\n        height,\n        left,\n        top\n      } = rect.current;\n      const x = event.clientX - left;\n      const y = event.clientY - top;\n      state.pointer.set(x / width * 2 - 1, -(y / height) * 2 + 1);\n      state.raycaster.setFromCamera(state.pointer, state.camera);\n    }\n  }, [rect]);\n  const [ready, toggle] = React.useReducer(() => true, false);\n  React.useEffect(() => {\n    var _track$current2;\n\n    // We need the tracking elements bounds beforehand in order to inject it into the portal\n    rect.current = (_track$current2 = track.current) == null ? void 0 : _track$current2.getBoundingClientRect(); // And now we can proceed\n\n    toggle();\n  }, []);\n  return ready && createPortal( /*#__PURE__*/React.createElement(Container, {\n    canvasSize: size,\n    frames: frames,\n    scene: scene,\n    track: track,\n    rect: rect,\n    index: index\n  }, children), virtualScene, {\n    events: {\n      compute,\n      priority: index\n    },\n    size: {\n      width: rect.current.width,\n      height: rect.current.height\n    }\n  });\n};\n\nexport { View };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}